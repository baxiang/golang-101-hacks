注：本文是对[golang-101-hacks](https://nanxiao.gitbooks.io/golang-101-hacks/)中文翻译。
Go支持多维切片，再此只对二维切片切片做介绍。日常生活中通常会使用到二维切片，而多维似乎并不多见。如果你经常使用多维切片，个人认为代码极不友好，也不容易维护，因此可以试试有没有更好的方法去解决多维的问题;另外的原因是多维切片和二维切片的原理是一样的，如果你对二维切片理解的很好，可以做到一通百通。
查看下面的demo
```
package main

import "fmt"

func main() {
    s := make([][]int, 2)
    fmt.Println(len(s), cap(s), &s[0])

    s[0] = []int{1, 2, 3}
    fmt.Println(len(s[0]), cap(s[0]), &s[0][0])

    s[1] = make([]int, 3, 5)
    fmt.Println(len(s[1]), cap(s[1]), &s[1][0])
}
```
使用gdb做断点调试
```
5       func main() {
(gdb) n
6               s := make([][]int, 2)
(gdb)
7               fmt.Println(len(s), cap(s), &s[0])
(gdb)
2 2 &[]
9               s[0] = []int{1, 2, 3}
(gdb) p &s
$1 = (struct [][]int *) 0xc82003fe70
(gdb) x/24xb 0xc82003fe70
0xc82003fe70:   0x40    0x02    0x01    0x20    0xc8    0x00    0x00    0x00
0xc82003fe78:   0x02    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0xc82003fe80:   0x02    0x00    0x00    0x00    0x00    0x00    0x00    0x00
```
s是一个二维切片(起始内存地址是0xc82003fe70)，同时它包含的元素也是切片，通过断点查看元素:
```
(gdb) x/48xb 0xc820010240

0xc820010240:   0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0xc820010248:   0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0xc820010250:   0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0xc820010258:   0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0xc820010260:   0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0xc820010268:   0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
```
所有的内存内容都是0，继续一步步往下执行:
```
(gdb) n
10              fmt.Println(len(s[0]), cap(s[0]), &s[0][0])
(gdb)
3 3 0xc82000e220
12              s[1] = make([]int, 3, 5)
```
现在，s已包含一个切片元素，查看它的底层数组:
```
(gdb) x/48xb 0xc820010240
0xc820010240:   0x20    0xe2    0x00    0x20    0xc8    0x00    0x00    0x00
0xc820010248:   0x03    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0xc820010250:   0x03    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0xc820010258:   0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0xc820010260:   0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0xc820010268:   0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
```
此时，s[0]的指针、长度和的容量发生了改变，与之前fmt.Println的输出相同。
查看s[0]的底层数组:
```
(gdb) x/24xb 0xc82000e220
0xc82000e220:   0x01    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0xc82000e228:   0x02    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0xc82000e230:   0x03    0x00    0x00    0x00    0x00    0x00    0x00    0x00
```
我们可查看到3个元素1，2，3
同理查看s[1]
Following the same method to check the s[1]:
```
(gdb) n
13              fmt.Println(len(s[1]), cap(s[1]), &s[1][0])
(gdb)
3 5 0xc820010270
14      }
(gdb) x/48xb 0xc820010240
0xc820010240:   0x20    0xe2    0x00    0x20    0xc8    0x00    0x00    0x00
0xc820010248:   0x03    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0xc820010250:   0x03    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0xc820010258:   0x70    0x02    0x01    0x20    0xc8    0x00    0x00    0x00
0xc820010260:   0x03    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0xc820010268:   0x05    0x00    0x00    0x00    0x00    0x00    0x00    0x00
(gdb) x/40xb 0xc820010270
0xc820010270:   0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0xc820010278:   0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0xc820010280:   0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0xc820010288:   0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0xc820010290:   0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
```
到此可以看到s包含了它的slice元素的所有信息，并且s[1]的元素被初始化为0。
